import json
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick # For percentage formatting
import matplotlib.patches as mpatches # For custom legend
import seaborn as sns
import os
import math # For ceiling division

# --- 配置 ---
log_file = 'log/operator_latency_log.jsonl'
output_dir = 'plots'
plot_filename = 'operator_latency_breakdown_per_query.png' # New filename

# --- 确保绘图目录存在 ---
os.makedirs(output_dir, exist_ok=True)
print(f"Plots will be saved to directory: {output_dir}")

# --- 加载日志数据 ---
data = []
try:
    with open(log_file, 'r', encoding='utf-8') as f:
        for line in f:
            try:
                # Skip lines that might be incomplete or just error messages if needed
                log_entry = json.loads(line)
                # Basic check if it looks like a valid entry
                if 'query_index' in log_entry and 'status' in log_entry:
                     data.append(log_entry)
            except json.JSONDecodeError as e:
                print(f"Warning: Skipping unparseable log line: {e} - Line content: {line.strip()}")
except FileNotFoundError:
    print(f"Error: Log file not found: {log_file}")
    exit()
except Exception as e:
    print(f"Error reading log file: {e}")
    exit()

if not data:
    print("Error: No valid data found in the log file.")
    exit()

# 转换为 Pandas DataFrame
df = pd.DataFrame(data)

# --- Check if essential columns exist ---
required_cols = ['status', 'query_index', 'total_time_seconds', 'operator_timings', 'profiling_error']
if not all(col in df.columns for col in required_cols):
    # Try to provide more specific feedback
    missing_cols = [col for col in required_cols if col not in df.columns]
    print(f"Error: Log file is missing one or more required columns: {missing_cols}")
    print("This likely means the 'operator_latency_profiling.py' script that generated the log is not the correct version.")
    print(f"Available columns in the log file: {df.columns.tolist()}")
    exit()

# --- Check specifically for operator_timings column ---
if 'operator_timings' not in df.columns:
    print("\n--- ERROR ---")
    print("The 'operator_timings' column is missing from the log data.")
    print("This means the profiling script did not successfully log the detailed operator timings.")
    print("Please ensure:")
    print("  1. You ran the latest version of 'operator_latency_profiling.py'.")
    print("  2. That script executed without errors related to parsing or file access.")
    print("  3. The log file 'log/operator_latency_log.jsonl' was correctly generated by the latest script run.")
    print("Available columns in the current log data:", df.columns.tolist())
    print("--- END ERROR ---\n")

    # Fallback to plotting only total time if possible
    df_total_success = df[df['status'] == 'SUCCESS'].copy()
    if not df_total_success.empty:
         print("Attempting to plot total query times as fallback...")
         df_total_success['query_index_str'] = df_total_success['query_index'].astype(str)
         df_total_success['total_time_ms'] = df_total_success['total_time_seconds'] * 1000
         fig, ax = plt.subplots(1, 1, figsize=(8, 6))
         # Group by query index first to sum up any potential duplicates before plotting
         total_time_plot_data_fallback = df_total_success.groupby('query_index_str')['total_time_ms'].sum().reset_index()
         sns.barplot(x='query_index_str', y='total_time_ms', data=total_time_plot_data_fallback, ax=ax, palette='viridis')
         ax.set_title('Total Execution Time per Query (Operator Data Missing)')
         ax.set_xlabel('Query Index')
         ax.set_ylabel('Total Duration (ms)')
         plt.tight_layout()
         plot_path = os.path.join(output_dir, "total_time_missing_operators_" + plot_filename)
         try:
            plt.savefig(plot_path)
            print(f"Total time plot saved to: {plot_path}")
         except Exception as e:
             print(f"Error saving total time plot: {e}")
         plt.show()
    exit() # Exit after showing the error and fallback plot

# --- 数据预处理 ---
# Now we know 'operator_timings' exists, proceed with filtering
# Filter based on the content of the operator_timings list
# Also filter out entries where profiling_error indicates an issue reading the file
df_success = df[(df['status'] == 'SUCCESS') &
                (df['profiling_error'].isnull()) & # Ensure no file read error
                (df['operator_timings'].apply(lambda x: isinstance(x, list) and len(x) > 0 and not any('error' in op for op in x if isinstance(op, dict))))].copy()

if df_success.empty:
    print("Error: No successful query records with valid (non-empty, no error entries, no file read error) operator timings found in the log for detailed plotting.")
    # Attempt to plot total time if there are successes, even if timings list is empty/invalid/read_error
    df_total_success = df[df['status'] == 'SUCCESS'].copy()
    if not df_total_success.empty:
         print("Attempting to plot total query times...")
         # (Duplicate fallback code - can be refactored, but keeping simple for now)
         df_total_success['query_index_str'] = df_total_success['query_index'].astype(str)
         df_total_success['total_time_ms'] = df_total_success['total_time_seconds'] * 1000
         fig, ax = plt.subplots(1, 1, figsize=(8, 6))
         total_time_plot_data_fallback2 = df_total_success.groupby('query_index_str')['total_time_ms'].sum().reset_index()
         sns.barplot(x='query_index_str', y='total_time_ms', data=total_time_plot_data_fallback2, ax=ax, palette='viridis')
         ax.set_title('Total Execution Time per Query (Invalid/Missing Operator Data)')
         ax.set_xlabel('Query Index')
         ax.set_ylabel('Total Duration (ms)')
         plt.tight_layout()
         plot_path = os.path.join(output_dir, "total_time_invalid_operators_" + plot_filename)
         try:
            plt.savefig(plot_path)
            print(f"Total time plot saved to: {plot_path}")
         except Exception as e:
             print(f"Error saving total time plot: {e}")
         plt.show()
    exit()

# --- Extract Operator Data ---
operator_data = []
for index, row in df_success.iterrows():
    query_idx = row['query_index']
    query_text = row['query'] # Get query text for titles
    timings = row.get('operator_timings', [])
    if isinstance(timings, list):
        for op in timings:
            if isinstance(op, dict) and 'operator_name' in op and 'duration_ms' in op and isinstance(op['duration_ms'], (int, float)) and op['duration_ms'] > 0: # Ensure duration > 0
                operator_data.append({
                    'query_index': query_idx,
                    'query_text': query_text.split('\n')[0][:50] + "...", # First 50 chars of query
                    'operator_name': op['operator_name'],
                    'duration_ms': op['duration_ms']
                })

if not operator_data:
     print("Error: Failed to extract valid operator details with positive duration.")
     exit()

df_operators = pd.DataFrame(operator_data)
df_operators['duration_ms'] = pd.to_numeric(df_operators['duration_ms'], errors='coerce')
df_operators.dropna(subset=['duration_ms'], inplace=True)

# --- 绘图 ---
# Get unique query indices and operators for layout and colors
valid_query_indices = sorted(df_operators['query_index'].unique())
all_operators = sorted(df_operators['operator_name'].unique())
n_queries = len(valid_query_indices)

# Create consistent color map for operators
num_operators = len(all_operators)
cmap_name = 'tab20' if num_operators <= 20 else 'viridis' # Choose colormap
colors = plt.cm.get_cmap(cmap_name, num_operators)
operator_colors = {op: colors(i) for i, op in enumerate(all_operators)}

# Determine subplot layout (1 total time + N query breakdowns)
n_plots = 1 + n_queries
ncols = 2 # Adjust number of columns if desired
nrows = math.ceil(n_plots / ncols)
figsize_width = 8 * ncols
figsize_height = 4 * nrows # Adjust height per row

sns.set_theme(style="whitegrid")
fig, axes = plt.subplots(nrows, ncols, figsize=(figsize_width, figsize_height), squeeze=False) # Ensure axes is always 2D
axes = axes.flatten() # Flatten for easy iteration

fig.suptitle('Query Performance: Total Time & Operator Breakdown per Query', fontsize=18)

# --- Plot 1: Total Execution Time ---
ax_total = axes[0]
df_success['query_index_str'] = df_success['query_index'].astype(str)
df_success['total_time_ms'] = df_success['total_time_seconds'] * 1000
total_time_plot_data = df_success.groupby('query_index_str')['total_time_ms'].sum().reset_index()
sns.barplot(x='query_index_str', y='total_time_ms', data=total_time_plot_data, ax=ax_total, palette='viridis')
ax_total.set_title('Total Execution Time per Query')
ax_total.set_xlabel('Query Index')
ax_total.set_ylabel('Total Duration (ms)')
for container in ax_total.containers:
    ax_total.bar_label(container, fmt='%.1f', fontsize=9, padding=3)

# --- Plots 2 onwards: Per-Query Operator Breakdown ---
plot_idx = 1
for query_idx in valid_query_indices:
    if plot_idx >= len(axes): break # Avoid index out of bounds if layout calculation is off

    ax = axes[plot_idx]
    query_ops_df = df_operators[df_operators['query_index'] == query_idx].copy()
    query_text_snippet = query_ops_df['query_text'].iloc[0] if not query_ops_df.empty else ""

    query_total_op_time = query_ops_df['duration_ms'].sum()

    if query_total_op_time > 0:
        query_ops_df['percentage'] = (query_ops_df['duration_ms'] / query_total_op_time) * 100
        # Group identical operators within the same query
        op_percentages = query_ops_df.groupby('operator_name')['percentage'].sum().sort_values(ascending=False)

        left = 0
        for op_name, perc in op_percentages.items():
            color = operator_colors.get(op_name, '#808080') # Default grey if somehow missing
            ax.barh(y=0, width=perc, left=left, height=0.5, label=op_name, color=color, edgecolor='white')
            left += perc

        ax.set_title(f'Query {query_idx} Breakdown\n"{query_text_snippet}"')
        ax.set_xlabel('Percentage of Total Operator Time')
        ax.set_xlim(0, max(101, left + 5)) # Adjust xlim slightly beyond 100%
        ax.xaxis.set_major_formatter(mtick.PercentFormatter())
        ax.set_yticks([]) # Hide y-axis ticks/label for the horizontal bar
        ax.margins(y=0.4) # Add some vertical margin

    else:
        ax.text(0.5, 0.5, 'No operator time recorded', horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, color='grey')
        ax.set_title(f'Query {query_idx} Breakdown')
        ax.set_xticks([])
        ax.set_yticks([])

    plot_idx += 1

# --- Hide any unused subplots ---
for i in range(plot_idx, len(axes)):
    axes[i].set_visible(False)

# --- Create Overall Legend ---
handles = [mpatches.Patch(color=operator_colors[op], label=op) for op in all_operators]
# Place legend outside the plots
fig.legend(handles=handles, title='Operators', bbox_to_anchor=(0.98, 0.95), loc='upper left', fontsize='medium', title_fontsize='large')

# --- Adjust layout and save ---
# Adjust rect to make space for suptitle and legend
fig.tight_layout(rect=[0, 0, 0.9, 0.95]) # May need fine-tuning
plot_path = os.path.join(output_dir, plot_filename)
try:
    plt.savefig(plot_path, bbox_inches='tight') # Use bbox_inches='tight' for legend
    print(f"Plot saved to: {plot_path}")
except Exception as e:
    print(f"Error saving plot: {e}")

plt.show() # 在屏幕上显示绘图 (如果环境支持)